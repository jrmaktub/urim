// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

interface OptimisticOracleV3Interface {
    function assertTruth(
        bytes memory claim,
        address asserter,
        address callbackRecipient,
        address sovereignSecurity,
        uint64 liveness,
        IERC20 currency,
        uint256 bond,
        bytes32 identifier,
        bytes32 domainId
    ) external returns (bytes32 assertionId);

    function settleAssertion(bytes32 assertionId) external;

    function getAssertion(
        bytes32 assertionId
    )
        external
        view
        returns (
            bool,
            address,
            address,
            address,
            uint64,
            IERC20,
            uint256,
            bytes32,
            bytes32,
            bytes memory
        );

    function defaultIdentifier() external view returns (bytes32);

    function getMinimumBond(address currency) external view returns (uint256);
}

interface OptimisticOracleV3CallbackRecipientInterface {
    function assertionResolvedCallback(
        bytes32 assertionId,
        bool assertedTruthfully
    ) external;
    function assertionDisputedCallback(bytes32 assertionId) external;
}

contract HondurasPresidentialElectionMarket is
    ReentrancyGuard,
    Ownable,
    OptimisticOracleV3CallbackRecipientInterface
{
    IERC20 public immutable usdc;

    uint256 public nasrallaShares;
    uint256 public moncadaShares;
    uint256 public asfuraShares;

    uint256 public constant INITIAL_SHARES = 1 * 1e6;
    uint256 public k;

    mapping(address => uint256) public userSharesNasralla;
    mapping(address => uint256) public userSharesMoncada;
    mapping(address => uint256) public userSharesAsfura;
    
    uint256 public seedAmount;
    mapping(address => uint256) public userDeposits;

    enum MarketState {
        OPEN,
        CLOSED,
        RESOLVED
    }
    MarketState public state;

    uint256 public immutable MARKET_CLOSE_TIME;

    uint8 public winningCandidate;

    OptimisticOracleV3Interface public immutable oo;
    uint64 public constant ASSERTION_LIVENESS = 7200;
    uint256 public constant ASSERTION_REWARD = 1 * 1e6;
    bytes32 public assertionId;
    address public asserter;
    bool public rewardPaid;

    uint256 public constant FEE_PERCENT = 50;
    uint256 public constant FEE_DENOMINATOR = 10000;
    uint256 public collectedFees;

    bool public emergencyMode;

    event SharesPurchased(
        address indexed buyer,
        uint8 indexed candidateId,
        uint256 usdcAmount,
        uint256 sharesReceived,
        uint256 newPrice
    );

    event SharesSold(
        address indexed seller,
        uint8 indexed candidateId,
        uint256 sharesSold,
        uint256 usdcReceived,
        uint256 newPrice
    );

    event MarketAsserted(
        uint8 indexed candidateId,
        bytes32 indexed assertionId,
        address asserter
    );

    event MarketResolved(uint8 indexed winningCandidate);

    event WinningsClaimed(
        address indexed user,
        uint256 sharesRedeemed,
        uint256 usdcPayout
    );

    event EmergencyModeActivated();

    constructor(
        address _optimisticOracleV3,
        address _usdc
    ) Ownable(msg.sender) {
        oo = OptimisticOracleV3Interface(_optimisticOracleV3);
        usdc = IERC20(_usdc);
        MARKET_CLOSE_TIME = 1764558000;
        state = MarketState.OPEN;
        nasrallaShares = INITIAL_SHARES;
        moncadaShares = INITIAL_SHARES;
        asfuraShares = INITIAL_SHARES;
        k = INITIAL_SHARES * INITIAL_SHARES * INITIAL_SHARES;
    }

    function seedLiquidity(uint256 amount) external onlyOwner {
        require(state == MarketState.OPEN);
        require(amount >= ASSERTION_REWARD);
        seedAmount = amount;
        require(usdc.transferFrom(msg.sender, address(this), amount));
    }

    function buyShares(
        uint8 candidateId,
        uint256 usdcAmount,
        uint256 minShares
    ) external nonReentrant returns (uint256 sharesReceived) {
        require(state == MarketState.OPEN);
        require(block.timestamp < MARKET_CLOSE_TIME);
        require(candidateId >= 1 && candidateId <= 3);
        require(usdcAmount > 0);

        uint256 fee = (usdcAmount * FEE_PERCENT) / FEE_DENOMINATOR;
        uint256 totalCost = usdcAmount + fee;
        collectedFees += fee;

        sharesReceived = _calculateBuyShares(candidateId, usdcAmount);
        require(sharesReceived >= minShares);
        require(sharesReceived > 0);

        if (candidateId == 1) {
            require(nasrallaShares > sharesReceived);
            nasrallaShares -= sharesReceived;
            userSharesNasralla[msg.sender] += sharesReceived;
        } else if (candidateId == 2) {
            require(moncadaShares > sharesReceived);
            moncadaShares -= sharesReceived;
            userSharesMoncada[msg.sender] += sharesReceived;
        } else {
            require(asfuraShares > sharesReceived);
            asfuraShares -= sharesReceived;
            userSharesAsfura[msg.sender] += sharesReceived;
        }

        userDeposits[msg.sender] += totalCost;

        require(usdc.transferFrom(msg.sender, address(this), totalCost));

        uint256 newPrice = getCurrentPrice(candidateId);
        emit SharesPurchased(msg.sender, candidateId, totalCost, sharesReceived, newPrice);
        return sharesReceived;
    }

    function buySharesUSD(
        uint8 candidateId,
        uint256 usdcAmount
    ) external nonReentrant returns (uint256 sharesReceived) {
        require(state == MarketState.OPEN);
        require(block.timestamp < MARKET_CLOSE_TIME);
        require(candidateId >= 1 && candidateId <= 3);
        require(usdcAmount > 0);

        uint256 fee = (usdcAmount * FEE_PERCENT) / FEE_DENOMINATOR;
        uint256 totalCost = usdcAmount + fee;
        collectedFees += fee;

        sharesReceived = _calculateBuyShares(candidateId, usdcAmount);
        require(sharesReceived > 0);
        
        uint256 maxBuyable = (getCurrentShares(candidateId) * 95) / 100;
        require(sharesReceived < maxBuyable);

        if (candidateId == 1) {
            require(nasrallaShares > sharesReceived);
            nasrallaShares -= sharesReceived;
            userSharesNasralla[msg.sender] += sharesReceived;
        } else if (candidateId == 2) {
            require(moncadaShares > sharesReceived);
            moncadaShares -= sharesReceived;
            userSharesMoncada[msg.sender] += sharesReceived;
        } else {
            require(asfuraShares > sharesReceived);
            asfuraShares -= sharesReceived;
            userSharesAsfura[msg.sender] += sharesReceived;
        }

        userDeposits[msg.sender] += totalCost;

        require(usdc.transferFrom(msg.sender, address(this), totalCost));

        uint256 newPrice = getCurrentPrice(candidateId);
        emit SharesPurchased(msg.sender, candidateId, totalCost, sharesReceived, newPrice);
        return sharesReceived;
    }

    function sellShares(
        uint8 candidateId,
        uint256 shareAmount,
        uint256 minUsdc
    ) external nonReentrant returns (uint256 usdcReceived) {
        require(state == MarketState.OPEN);
        require(block.timestamp < MARKET_CLOSE_TIME);
        require(candidateId >= 1 && candidateId <= 3);
        require(shareAmount > 0);

        uint256 userShares;
        if (candidateId == 1) {
            userShares = userSharesNasralla[msg.sender];
        } else if (candidateId == 2) {
            userShares = userSharesMoncada[msg.sender];
        } else {
            userShares = userSharesAsfura[msg.sender];
        }
        require(userShares >= shareAmount);

        usdcReceived = _calculateSellUsdc(candidateId, shareAmount);

        uint256 fee = (usdcReceived * FEE_PERCENT) / FEE_DENOMINATOR;
        uint256 amountAfterFee = usdcReceived - fee;
        collectedFees += fee;

        require(amountAfterFee >= minUsdc);

        if (candidateId == 1) {
            nasrallaShares += shareAmount;
            userSharesNasralla[msg.sender] -= shareAmount;
        } else if (candidateId == 2) {
            moncadaShares += shareAmount;
            userSharesMoncada[msg.sender] -= shareAmount;
        } else {
            asfuraShares += shareAmount;
            userSharesAsfura[msg.sender] -= shareAmount;
        }

        if (userDeposits[msg.sender] > amountAfterFee) {
            userDeposits[msg.sender] -= amountAfterFee;
        } else {
            userDeposits[msg.sender] = 0;
        }

        require(usdc.transfer(msg.sender, amountAfterFee));

        uint256 newPrice = getCurrentPrice(candidateId);
        emit SharesSold(msg.sender, candidateId, shareAmount, amountAfterFee, newPrice);
        return amountAfterFee;
    }

    function sellSharesUSD(
        uint8 candidateId,
        uint256 usdcAmount
    ) external nonReentrant returns (uint256 sharesSold) {
        require(state == MarketState.OPEN);
        require(block.timestamp < MARKET_CLOSE_TIME);
        require(candidateId >= 1 && candidateId <= 3);
        require(usdcAmount > 0);

        uint256 usdcBeforeFee = (usdcAmount * FEE_DENOMINATOR) / (FEE_DENOMINATOR - FEE_PERCENT);
        sharesSold = _calculateSharesNeededForUSDC(candidateId, usdcBeforeFee);

        uint256 userShares;
        if (candidateId == 1) {
            userShares = userSharesNasralla[msg.sender];
            require(userShares >= sharesSold);
            nasrallaShares += sharesSold;
            userSharesNasralla[msg.sender] -= sharesSold;
        } else if (candidateId == 2) {
            userShares = userSharesMoncada[msg.sender];
            require(userShares >= sharesSold);
            moncadaShares += sharesSold;
            userSharesMoncada[msg.sender] -= sharesSold;
        } else {
            userShares = userSharesAsfura[msg.sender];
            require(userShares >= sharesSold);
            asfuraShares += sharesSold;
            userSharesAsfura[msg.sender] -= sharesSold;
        }

        uint256 fee = (usdcBeforeFee * FEE_PERCENT) / FEE_DENOMINATOR;
        collectedFees += fee;

        if (userDeposits[msg.sender] > usdcAmount) {
            userDeposits[msg.sender] -= usdcAmount;
        } else {
            userDeposits[msg.sender] = 0;
        }

        require(usdc.transfer(msg.sender, usdcAmount));

        uint256 newPrice = getCurrentPrice(candidateId);
        emit SharesSold(msg.sender, candidateId, sharesSold, usdcAmount, newPrice);
        return sharesSold;
    }

    function getCurrentPrice(uint8 candidateId) public view returns (uint256) {
        require(candidateId >= 1 && candidateId <= 3);

        uint256 inversePriceA = (1e18 * INITIAL_SHARES) / nasrallaShares;
        uint256 inversePriceB = (1e18 * INITIAL_SHARES) / moncadaShares;
        uint256 inversePriceC = (1e18 * INITIAL_SHARES) / asfuraShares;

        uint256 totalInversePrice = inversePriceA + inversePriceB + inversePriceC;

        if (candidateId == 1) {
            return (inversePriceA * 1e18) / totalInversePrice;
        } else if (candidateId == 2) {
            return (inversePriceB * 1e18) / totalInversePrice;
        } else {
            return (inversePriceC * 1e18) / totalInversePrice;
        }
    }

    function getCurrentShares(uint8 candidateId) internal view returns (uint256) {
        if (candidateId == 1) return nasrallaShares;
        if (candidateId == 2) return moncadaShares;
        return asfuraShares;
    }

    function _calculateBuyShares(
        uint8 candidateId,
        uint256 usdcAmount
    ) internal view returns (uint256) {
        uint256 currentShares;

        if (candidateId == 1) {
            currentShares = nasrallaShares;
        } else if (candidateId == 2) {
            currentShares = moncadaShares;
        } else {
            currentShares = asfuraShares;
        }

        uint256 maxBuyable = (currentShares * 95) / 100;

        uint256 reservedAmount = rewardPaid ? 0 : ASSERTION_REWARD;
        uint256 totalPoolValue = usdc.balanceOf(address(this)) -
            collectedFees -
            reservedAmount;
        require(totalPoolValue > 0);

        uint256 sharesToBuy = (usdcAmount * currentShares) /
            (totalPoolValue + usdcAmount);

        if (sharesToBuy > maxBuyable) {
            sharesToBuy = maxBuyable;
        }

        return sharesToBuy;
    }

    function _calculateSellUsdc(
        uint8 candidateId,
        uint256 shareAmount
    ) internal view returns (uint256) {
        uint256 currentShares;

        if (candidateId == 1) {
            currentShares = nasrallaShares;
        } else if (candidateId == 2) {
            currentShares = moncadaShares;
        } else {
            currentShares = asfuraShares;
        }

        uint256 reservedAmount = rewardPaid ? 0 : ASSERTION_REWARD;
        uint256 totalValue = usdc.balanceOf(address(this)) -
            collectedFees -
            reservedAmount;
        return (shareAmount * totalValue) / (currentShares + shareAmount);
    }

    function _calculateSharesNeededForUSDC(
        uint8 candidateId,
        uint256 desiredUSDC
    ) internal view returns (uint256) {
        uint256 currentShares;

        if (candidateId == 1) {
            currentShares = nasrallaShares;
        } else if (candidateId == 2) {
            currentShares = moncadaShares;
        } else {
            currentShares = asfuraShares;
        }

        uint256 reservedAmount = rewardPaid ? 0 : ASSERTION_REWARD;
        uint256 totalValue = usdc.balanceOf(address(this)) -
            collectedFees -
            reservedAmount;

        require(totalValue > desiredUSDC);
        return (desiredUSDC * currentShares) / (totalValue - desiredUSDC);
    }

    function closeMarket() external {
        require(block.timestamp >= MARKET_CLOSE_TIME);
        require(state == MarketState.OPEN);
        state = MarketState.CLOSED;
    }

    function assertMarket(uint8 candidateId) external returns (bytes32) {
        require(state == MarketState.CLOSED);
        require(assertionId == bytes32(0));
        require(candidateId >= 1 && candidateId <= 3);

        uint256 bond = oo.getMinimumBond(address(usdc));

        require(usdc.transferFrom(msg.sender, address(this), bond));
        require(usdc.approve(address(oo), bond));

        bytes memory claim = _composeClaim(candidateId);

        assertionId = oo.assertTruth(
            claim,
            msg.sender,
            address(this),
            address(0),
            ASSERTION_LIVENESS,
            usdc,
            bond,
            oo.defaultIdentifier(),
            bytes32(0)
        );

        asserter = msg.sender;
        winningCandidate = candidateId;

        emit MarketAsserted(candidateId, assertionId, msg.sender);
        return assertionId;
    }

    function resolveMarket(uint8 _winningCandidate) external onlyOwner {
        require(state == MarketState.CLOSED);
        require(_winningCandidate >= 1 && _winningCandidate <= 3);
        winningCandidate = _winningCandidate;
        state = MarketState.RESOLVED;
        emit MarketResolved(_winningCandidate);
    }

    function emergencyAction(uint8 _winningCandidate) external onlyOwner {
        require(_winningCandidate <= 3);
        emergencyMode = true;
        state = MarketState.RESOLVED;
        if (_winningCandidate > 0) {
            winningCandidate = _winningCandidate;
            emit MarketResolved(_winningCandidate);
        }
        emit EmergencyModeActivated();
    }

    function emergencyRefund() external nonReentrant {
        require(emergencyMode);
        require(winningCandidate == 0);
        
        uint256 deposit = userDeposits[msg.sender];
        require(deposit > 0);
        
        userDeposits[msg.sender] = 0;
        userSharesNasralla[msg.sender] = 0;
        userSharesMoncada[msg.sender] = 0;
        userSharesAsfura[msg.sender] = 0;
        
        require(usdc.transfer(msg.sender, deposit));
    }

    function emergencyWithdrawRemaining() external onlyOwner {
        require(emergencyMode);
        uint256 balance = usdc.balanceOf(address(this));
        require(usdc.transfer(owner(), balance));
        seedAmount = 0;
    }

    function assertionResolvedCallback(
        bytes32 _assertionId,
        bool assertedTruthfully
    ) external override {
        require(msg.sender == address(oo));
        require(_assertionId == assertionId);

        if (assertedTruthfully) {
            state = MarketState.RESOLVED;
            require(usdc.transfer(asserter, ASSERTION_REWARD));
            rewardPaid = true;
            emit MarketResolved(winningCandidate);
        } else {
            assertionId = bytes32(0);
            winningCandidate = 0;
            asserter = address(0);
        }
    }

    function assertionDisputedCallback(bytes32) external override {}

    function _composeClaim(uint8 candidateId) internal pure returns (bytes memory) {
        string memory candidateName;

        if (candidateId == 1) {
            candidateName = "Salvador Alejandro Cesar Nasralla Salum";
        } else if (candidateId == 2) {
            candidateName = "Rixi Ramona Moncada Godoy";
        } else {
            candidateName = "Nasry Juan Asfura Zablah";
        }

        return abi.encodePacked(
            candidateName,
            " won the Honduras 2025 Presidential Election held on November 30, 2025."
        );
    }

    function claimWinnings() external nonReentrant returns (uint256 payout) {
        require(state == MarketState.RESOLVED);

        uint256 winningShares;
        if (winningCandidate == 1) {
            winningShares = userSharesNasralla[msg.sender];
            userSharesNasralla[msg.sender] = 0;
        } else if (winningCandidate == 2) {
            winningShares = userSharesMoncada[msg.sender];
            userSharesMoncada[msg.sender] = 0;
        } else {
            winningShares = userSharesAsfura[msg.sender];
            userSharesAsfura[msg.sender] = 0;
        }

        require(winningShares > 0);

        uint256 totalWinningShares;
        if (winningCandidate == 1) {
            totalWinningShares = INITIAL_SHARES - nasrallaShares;
        } else if (winningCandidate == 2) {
            totalWinningShares = INITIAL_SHARES - moncadaShares;
        } else {
            totalWinningShares = INITIAL_SHARES - asfuraShares;
        }

        uint256 totalBalance = usdc.balanceOf(address(this)) - collectedFees;
        uint256 totalPool = totalBalance > seedAmount ? totalBalance - seedAmount : totalBalance;
        payout = (winningShares * totalPool) / totalWinningShares;

        require(usdc.transfer(msg.sender, payout));
        emit WinningsClaimed(msg.sender, winningShares, payout);
        return payout;
    }

    function withdrawSeed() external onlyOwner {
        require(state == MarketState.RESOLVED);
        require(seedAmount > 0);
        uint256 seed = seedAmount;
        seedAmount = 0;
        require(usdc.transfer(owner(), seed));
    }

    function getAllPrices() external view returns (uint256, uint256, uint256) {
        return (getCurrentPrice(1), getCurrentPrice(2), getCurrentPrice(3));
    }

    function getUserShares(address user) external view returns (uint256, uint256, uint256) {
        return (userSharesNasralla[user], userSharesMoncada[user], userSharesAsfura[user]);
    }

    function withdrawFees() external onlyOwner {
        uint256 fees = collectedFees;
        collectedFees = 0;
        require(usdc.transfer(owner(), fees));
    }

    function getUserSharesInUSDC(address user, uint8 candidateId) external view returns (uint256) {
        uint256 shares;
        if (candidateId == 1) shares = userSharesNasralla[user];
        else if (candidateId == 2) shares = userSharesMoncada[user];
        else shares = userSharesAsfura[user];

        if (shares == 0) return 0;
        
        uint256 usdcValue = _calculateSellUsdc(candidateId, shares);
        uint256 fee = (usdcValue * FEE_PERCENT) / FEE_DENOMINATOR;
        return usdcValue - fee;
    }

    function getMarketTimeRemaining() external view returns (uint256) {
        if (block.timestamp >= MARKET_CLOSE_TIME) return 0;
        return MARKET_CLOSE_TIME - block.timestamp;
    }

    function getMarketCloseTime() external view returns (uint256) {
        return MARKET_CLOSE_TIME;
    }

    function getAssertionTimeRemaining() external view returns (uint256) {
        if (assertionId == bytes32(0)) return 0;
        if (state == MarketState.RESOLVED) return 0;
        if (assertionId != bytes32(0) && state == MarketState.CLOSED) {
            return ASSERTION_LIVENESS;
        }
        return 0;
    }

    function getAssertionId() external view returns (bytes32) {
        return assertionId;
    }

    function canSettleAssertion() external view returns (bool) {
        if (assertionId == bytes32(0)) return false;
        if (state == MarketState.RESOLVED) return false;
        return state == MarketState.CLOSED && assertionId != bytes32(0);
    }
}
